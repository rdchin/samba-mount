#!/bin/bash
#
VERSION="2017-01-07 15:00"
THIS_FILE="mountup_lib_gui.lib"
#
#@ Brief Description
#@
#@ This script will mount shared cifs (Samba) directories from one or more
#@ file servers. The shared (Samba) directories will be mounted on the
#@ corresponding mount-point (directories) on theLocal PC.
#@
#@ To add more file server names, share-points with corresponding mount-points,
#@ edit the text at the end of function f_server_arrays.
#@ Format <DELIMITER>//<Source File Server>/<Shared directory><DELIMITER>/<Mount-point on local PC>
#@
#@ After each edit made, please update Code History and VERSION.
#@
#@ Code Change History
#@
#@ 2017-01-07 *f_action_menu_gui bug fixed, check network connection when
#@              choosing menu item "Pick" mount-points.
#@
#@ 2017-01-04 *f_mount_gui added call to f_username_gui to enter SMB username. 
#@            *f_show_mount_points_gui added display of username with mount-point.
#@
#@ 2016-08-03 *mountup_gui.sh remove $GENERATED_FILE if it exists.
#@
#@ 2016-05-25 *mountup_lib_gui.lib changed to use Dialog's checklist.
#@             It will now cycle through the entire array of share-points
#@             one by one and if needed mount or dismount each one at a time.
#@            *mountup_update_gui.sh now calls mountup_gui.sh so that the 
#@             arrays of servers, share/mountpoints are refreshed before
#@             (dis)mounting of any share-points.
#@            *mountup_gui.sh can still be run by itself if there are
#@             changes in the list of file servers (no additions/deletions).
#@
#@ 2016-05-05 *Script works but after (dis)mounting it returns to Main Menu
#@             which is annoying. 
#@            *I tried to force the script flow so that if (dis)mounting in
#@             the sub-menu then force it not display the Main Menu again but
#@             instead simply regenerate the sub-menu and re-display it.
#@            *Unfortunately I could not force it so once any selection in
#@             the sub-menu is made, script flow exits to the Main Menu
#@             which I found annoying.
#@            *The complexity of this script is because the sub-menu is
#@             dynamic and changes whenever a server share-point is
#@             (dis)mounted and so the Dialog menu code must be regenerated.
#@            *Script mountup_update_gui.sh generates script mountup_gui.sh
#@             and should be run as new servers need to be added to the 
#@             Main Menu.
#@            *Running script mountup_gui.sh generates script mountup_gui2.sh
#@             where mountup_gui.sh displays the Main Menu while
#@             mountup_gui2.sh displays the sub-menu (Dis)Mount Menu.
#@
#@ 2016-05-01 *Script allows any number of shared directories.
#@            *Script now has a fully extensible Main Menu with menu items
#@             easily added in comment lines beginning with "#@@".
#@            *Script now has a fully extensible directory sub-menu with
#@             menu items easily added in comment lines beginning with "#@@".
#@            *These scripts are together:
#@             mountup_lib_gui.lib provides functions used by other scripts.
#@             mountup_update_gui.sh generates and updates mountup_gui.sh.
#@             mountup_update_gui.sh is the actual Server Menu.
#@
#@ 2016-03-31 *Posted on GitHub.com as a template.
#@
#@ 2016-03-25 *Rearranged functions as common, text, gui, and main program.
#@
#@ 2016-03-02 *f_mount_all_gui_2, f_mount_gui if mount fails either try again
#@             or abort mounting all remaining mount-points on the server.
#@
#@ 2016-02-09 *f_code_history_gui allow textbox to be as large as window size.
#@
#@ 2015-12-24 *f_mount_text added a mount command with no option -o password for
#@             Raspberry Pi Model 1.
#@
#@ 2015-12-21 *f_mount_gui added a mount command with no option -o password for
#@             Raspberry Pi Model 1.
#@
#@ 2015-12-01 *Created new script. Based this script on script, peapodup.sh
#@             which (dis)mounted one or more shared directories on a server.
#@            *(Dis)mount all shared directories of any given file-server.
#
#
# MOUNT COMMAND RETURN CODES
#       mount has the following return codes (the bits can be ORed):
#
#       0      success
#
#       1      incorrect invocation or permissions
#
#       2      system error (out of memory, cannot fork, no more loop devices)
#
#       4      internal mount bug
#
#       8      user interrupt
#
#       16     problems writing or locking /etc/mtab
#
#       32     mount failure
#
#       64     some mount succeeded
#
#
# +--------------------------------------------------------------------------+
# |                                                                          |
# | Add additional source file servers, share-points, and mount-points here. |
# |                                                                          |
# +--------------------------------------------------------------------------+
#
# Format <Delimiter>//<Source File Server>/<Shared directory><Delimiter>/<Mount-point on local PC><Delimiter><Shared directory description>
#
#@@//hansolo/public#@@/mnt/hansolo/public#@@Hansolo Server Publicly shared files.
#@@//hansolo/public/jobs#@@/mnt/hansolo/jobs#@@Hansolo Server Publicly shared job information.
#
#@@//chewbacca/photos#@@/mnt/chewbacca/photos#@@Chewbacca Server shared photos.
#
#@@//luke/school#@@/mnt/luke/school#@@Luke Server shared school files.
#
#@@//leia/music#@@/mnt/leia/music#@@Leia Server shared music.
#
#@@//yoda/public-no-backup#@@/mnt/yoda/public-no-backup#@@Yoda Server shared files not backed up.
#
#@@//r2d2/geekstuff#@@/mnt/r2d2/geekstuff#@@R2D2 Server shared geek stuff.
#@@//r2d2/geekstuff#@@/mnt/r2d2/geekscripts#@@R2D2 Server shared geek scripts.
#
#@@//c3po/library#@@/mnt/c3po/library#@@C3PO Server shared Library.
#
# Add your actual data below:
#
# +----------------------------------------+
# |       Function f_server_arrays         |
# +----------------------------------------+
#
#  Inputs: "mountup_lib_gui.lib" (THIS_FILE).
#    Uses: XSTR, SERVER_NAME, NEXT_SERVER_NAME, SERVER_NUM, ARRAY_NUM.
# Outputs: SERVER[$SERVER_NUM]=<Name of server>^<Description of shared directory>.
#          SRV[$SERVER_NUM]=<1st 2-letters of server name for pattern matching in menu case statement>.
#          SERVER_SP[SERVER_NUM]=<Server's shared directory to be mounted>.
#          LOCAL_MP[SERVER_NUM]=<Mount-point of local PC>.
#          SERVER_DESC[1]=<Description of Shared Directory contents>.
#
f_server_arrays () {
      # Create arrays to handle mount-point names and server source directory names.
      #
      # Example:
      # Server name is "hansolo"
      # Shared directory to be mounted is "//hansolo/public/contacts"
      # Local PC mount-point is "/mnt/hansolo/contacts"
      #
      #     SERVER[1]="hansolo"
      #     SRV[1]="ha" <1st 2-letters of server name for pattern matching in menu case statement>
      #     hansolo_SP[1]="//hansolo/public/contacts  # Share-point on hansolo.
      #     hansolo_MP[1]="/mnt/hansolo/contacts"     # Local mount-point on Local PC.
      #     hansolo_DESC[1]="Shared_contact_list"  # Description of shared folder contents (substitute <underscore> for <space> characters).
      #
      SERVER_NUM=0 # Initialize.
      SERVER_NAME="" # Initialize.
      ARRAY_NUM=1
      TEMP_FILE="mountup_temp.txt"
      #
      #        Field-1                                Field-2                                   Field-3                               Field-4
      # Format of XSTR="<Delimiter>//<Source File Server>/<Shared directory><Delimiter>/<Mount-point on local PC><Delimiter><Shared directory description>"
      # Read line of data having 3 delimiters and 4 fields. Save fields 2, 3, 4.
      # echo $(awk -F "$DELIMITER" '{ if ( $3 ) { print $2 "^" $3 "^" $4; }}' $THIS_FILE)
      #
      if [ -r $TEMP_FILE ] ; then
         rm $TEMP_FILE
      fi
      #      
      while read XSTR
      do
            case $XSTR in
                  \#@@*) echo $XSTR >>$TEMP_FILE
                  ;;
            esac
      done < mountup_lib_gui.lib
      #
      sed -i /echo*/d $TEMP_FILE # Delete last line in $TEMP_FILE which is actual code not data.
      #
      while read XSTR
      do
            # Since format of share-point directory is "//<SERVER_NAME>" the name is in <field-3> with delimiter "/".
            NEXT_SERVER_NAME=$(echo $XSTR | awk -F "/" '{ if ( $3 ) { print $3 }}')
            if [ "$SERVER_NAME" != "$NEXT_SERVER_NAME" ] ; then
               SERVER_NAME=$NEXT_SERVER_NAME
               let SERVER_NUM=$SERVER_NUM+1 # Increment server array index.
               ARRAY_NUM=1                  # Different server so reset index for share-point ond mount-point arrays.
            fi
            SERVER[$SERVER_NUM]="$SERVER_NAME"
            SRV[$SERVER_NUM]=${SERVER_NAME:0:2}  # SRV[n]=<the first 2-letters of the Server Name>
            #echo "SRV[$SERVER_NUM]=${SRV[$SERVER_NUM]}"      # Test diagnostic line.
            #
            # Set array $SERVER_NAME_SP[SERVER_NUM]=<field-2> or "Shared directory" of XSTR.
            ARRAY_NAME=$SERVER_NAME"_SP"
            ARRAY_VALUE=$(echo $XSTR | awk -F "#@@" '{ if ( $3 ) { print $2 }}')
            eval $ARRAY_NAME[$ARRAY_NUM]=$ARRAY_VALUE
            #echo "$ARRAY_NAME[$ARRAY_NUM]=${ARRAY_NAME[$ARRAY_NUM]}" # Test diagnostic line.
            #
            # Set array $SERVER_NAME_MP[SERVER_NUM]=<field-3> of XSTR.
            ARRAY_NAME=$SERVER_NAME"_MP"
            ARRAY_VALUE=$(echo $XSTR | awk -F "#@@" '{ if ( $3 ) { print $3 }}')
            #echo ARRAY_VALUE=$ARRAY_VALUE  # Test diagnostic line.
            #echo "$ARRAY_NAME[$ARRAY_NUM]=${$ARRAY_NAME[$ARRAY_NUM]}" # Test diagnostic line.
            eval $ARRAY_NAME[$ARRAY_NUM]=$ARRAY_VALUE
            #
            # Set array $SERVER NAME DESC[SERVER_NUM]=<field-4> of XSTR.
            ARRAY_NAME=$SERVER_NAME"_DESC"
            #echo XSTR=$XSTR  # Test diagnostic line.
            ARRAY_VALUE=$(echo $XSTR | awk -F "#@@" '{ if ( $3 ) { print $4 }}')
            ARRAY_VALUE=$(echo $ARRAY_VALUE | tr ' ' '_')
            #echo ARRAY_VALUE=$ARRAY_VALUE  # Test diagnostic line.
            eval $ARRAY_NAME[$ARRAY_NUM]=$ARRAY_VALUE
            #echo ${peapod_DESC[@]}  # Test diagnostic line.
            #
            let ARRAY_NUM=$ARRAY_NUM+1
      done < $TEMP_FILE
      if [ -r $TEMP_FILE ] ; then
         rm $TEMP_FILE
      fi
      unset XSTR SERVER_NUM ARRAY_NUM SERVER_NAME NEXT_SERVER_NAME # Throw out this variable.
} # End of f_server_arrays.
#
# +----------------------------------------+
# |      Function f_test_environment       |
# +----------------------------------------+
#
#  Inputs: $BASH_VERSION (System variable).
#    Uses: None.
# Outputs: None.
#
f_test_environment () {
      # Set default colors in case configuration file is not readable
      # or does not exist.
      #
      # Test the environment. Are you in the BASH environment?
      # $BASH_VERSION is null if you are not in the BASH environment.
      # Typing "sh" at the CLI may invoke a different shell other than BASH.
      # if [ -z "$BASH_VERSION" ]; then
      # if [ "$BASH_VERSION" = '' ]; then
      f_test_dash_txt
} # End of function f_test_environment.
#
# +----------------------------------------+
# |        Function f_test_dash_txt        |
# +----------------------------------------+
#
#  Inputs: None.
#    Uses: None.
# Outputs: None.
#
f_test_dash_txt () {
      # Set default colors in case configuration file is not readable
      # or does not exist.
      #
      echo -n $(tput sgr0) # Set font to normal color.
      if [ -z "$BASH_VERSION" ]; then
         clear # Clear screen.
         echo -n $(tput bold)
         echo -n $(tput setaf 1) # Set font to color red.
         echo "WARNING:"
         echo "You are using the DASH environment."
         echo "This script needs a BASH environment to run properly."
         echo $(tput sgr0) # Set font to normal color.
         echo "Ubuntu and Linux Mint default to DASH but also have BASH available."
         echo
         echo "Restart this script by typing:"
         echo -n $(tput bold)
         echo "       \"bash $THIS_FILE\""
         echo -n $(tput sgr0) # Set font to normal color.
         echo "at the command line prompt (without the quotation marks)."
         echo
         echo -n $(tput sgr0) # Set font to normal color.
         f_press_enter_key_to_continue
         f_abort_txt
      fi
} # End of function f_test_dash_txt.
#
# +----------------------------------------+
# |          Function f_detect_ui          |
# +----------------------------------------+
#
#  Inputs: None.
#    Uses: ERROR.
# Outputs: GUI (dialog, whiptail, text).
#
f_detect_ui () {
      command -v dialog >/dev/null
      # "&>/dev/null" does not work in Debian distro.
      # 1=standard messages, 2=error messages, &=both.
      ERROR=$?
      # Is Dialog GUI installed?
      if [ $ERROR -eq 0 ] ; then
         # Yes, Dialog installed.
         GUI="dialog"
      else
         # Is Whiptail GUI installed?
         command -v whiptail >/dev/null
         # "&>/dev/null" does not work in Debian distro.
         # 1=standard messages, 2=error messages, &=both.
         ERROR=$?
         if [ $ERROR -eq 0 ] ; then
            # Yes, Whiptail installed.
            GUI="whiptail"
         else
            # No CLI GUIs installed
            GUI="text"
         fi
      fi
} # End of function f_detect_ui.
#
# +----------------------------------------+
# |         Function f_script_path         |
# +----------------------------------------+
#
#  Inputs: $BASH_SOURCE (System variable).
#    Uses: None.
# Outputs: SCRIPT_PATH, THIS_DIR.
#
f_script_path () {
      # BASH_SOURCE[0] gives the filename of the script.
      # dirname "{$BASH_SOURCE[0]}" gives the directory of the script
      # Execute commands: cd <script directory> and then pwd
      # to get the directory of the script.
      # NOTE: This code does not work with symlinks in directory path.
      #
      # !!!Non-BASH environments will give error message about line below!!!
      SCRIPT_PATH=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )
      THIS_DIR=$SCRIPT_PATH  # Set $THIS_DIR to location of this script.

} # End of function f_script_path.
#
# +----------------------------------------+
# | Function f_press_enter_key_to_continue |
# +----------------------------------------+
#
#  Inputs: None.
#    Uses: X.
# Outputs: None.
#
f_press_enter_key_to_continue () { # Display message and wait for user input.
      echo
      echo -n "Press '"Enter"' key to continue."
      read X
      unset X  # Throw out this variable.
} # End of function f_press_enter_key_to_continue.
#
# +----------------------------------------+
# |        Function f_test_connection      |
# +----------------------------------------+
#
#  Inputs: $1=GUI - "text", "dialog" or "whiptail" The CLI GUI application in use.
#          $2 - Network name of server. 
#    Uses: None.
# Outputs: ERROR. 
#
f_test_connection () {
      # Check if there is an internet connection before doing a download.
      case $1 in
           whiptail | dialog)
           ping -c 1 -q $2 >/dev/null # Ping server address.
           ERROR=$?
           if [ $ERROR -ne 0 ] ; then
              $1 --title "Ping Test Connection" --msgbox "Network connnection to $2 file server failed.\nCannot (dis)mount shared directories." 7 70
           fi
           ;;
           text)
           echo
           echo "Test LAN Connection to $2"
           echo
           ping -c 1 -q $2  # Ping server address.
           ERROR=$?
           echo
           if [ $ERROR -ne 0 ] ; then
              echo -n $(tput setaf 1) # Set font to color red.
              echo -n $(tput bold)
              echo ">>> Network connnection to $2 failed. <<<"
              echo "    Cannot (dis)mount shared directories."
              echo -n $(tput sgr0)
              f_press_enter_key_to_continue
           fi
           ;;
      esac
} # End of function f_test_connection.
#
# +----------------------------------------+
# |         Function f_username_gui        |
# +----------------------------------------+
#
#  Inputs: $1=GUI - "dialog" or "whiptail" The CLI GUI application in use.
#          $2=USERNAME (default).
#    Uses: temp.txt.
# Outputs: SMBUSER, ERROR.
#
f_username_gui() {
      $1 --title "SMB mount-point user name" --inputbox "Enter SMB mount-point user name:" 10 50 $2 2>temp.txt
      ERROR=$?
      SMBUSER=$(cat temp.txt)
      #
      if [ -r temp.txt ] ; then
         rm temp.txt
      fi
      case $ERROR in
           1) SMBUSER="" ;;   # <Cancel> button pressed.
           255) SMBUSER="" ;; # <ESC> key pressed.
      esac
} # End of function f_username_gui.
#
# +----------------------------------------+
# |         Function f_password_gui        |
# +----------------------------------------+
#
#  Inputs: $1=GUI - "dialog" or "whiptail" The CLI GUI application in use.
#          $2=MP - Mount-point to display on --passwordbox.
#    Uses: temp.txt.
# Outputs: PASSWORD, ERROR.
#
f_password_gui() {
      PASSWORD=""
      if [ $1 = "dialog" ] ; then
         $1 --title "Password for $2" --clear --insecure --passwordbox "Enter SMB mount-point password:" 10 70 2>temp.txt
         ERROR=$?
      else
         $1 --title "Password for $2" --clear --passwordbox "Enter SMB mount-point password:" 10 70 2>temp.txt
         ERROR=$?
      fi     
      PASSWORD=$(cat temp.txt)
      #
      if [ -r temp.txt ] ; then
         rm temp.txt
      fi
      case $ERROR in
           1) PASSWORD="" ;;   # <Cancel> button pressed.
           255) PASSWORD="" ;; # <ESC> key pressed.
      esac
} # End of function f_password_gui.
#
# +------------------------------------+
# |        Function f_about_gui        |
# +------------------------------------+
#
#  Inputs: $1=GUI - "dialog" or "whiptail" The CLI GUI application in use.
#          THIS_FILE, VERSION.
#    Uses: None.
# Outputs: None.
#
f_about_gui () {
      THIS_FILE="mountup_lib_gui.lib"
      $1 --title "About this script" --msgbox "Script: $THIS_FILE. Version: $VERSION" 8 70
} # End of f_about_gui.
#
# +----------------------------------------+
# |       Function f_code_history_gui      |
# +----------------------------------------+
#
#  Inputs: $1=GUI - "dialog" or "whiptail" The CLI GUI application in use.
#          THIS_DIR, THIS_FILE. 
#    Uses: None.
# Outputs: temp.txt.
#
f_code_history_gui () {
      THIS_FILE="mountup_lib_gui.lib"
      # Display Help (all lines beginning with "#@" but do not print "#@").
      # sed substitutes null for "#@" at the beginning of each line
      # so it is not printed.
      # less -P customizes prompt for
      # %f <FILENAME> page <num> of <pages> (Spacebar, PgUp/PgDn . . .)
      date>temp.txt ; echo "Script: $THIS_FILE">>temp.txt
      f_script_path
      sed -n 's/^#@//'p $THIS_DIR/$THIS_FILE >> temp.txt
      # Get the screen resolution or X-window size.
      # Get rows (height).
      Y=$(stty size | awk '{ print $1 }')
      # Get columns (width).
      X=$(stty size | awk '{ print $2 }')
      #
      $1 --title "Code History (use arrow keys to scroll up/down/side-ways)" --textbox temp.txt $Y $X
      #
      if [ -r temp.txt ] ; then
         rm temp.txt
      fi
} # End of function f_code_history_gui.
#
# +----------------------------------------+
# |    Function f_show_mount_points_gui    |
# +----------------------------------------+
#
#  Inputs: $1=GUI - "dialog" or "whiptail" The CLI GUI application in use.
#          $THIS_FILE, 
#    Uses: X, Y, ERROR, temp.txt.
# Outputs: None.
#
f_show_mount_points_gui () {
      date >temp.txt
      echo >>temp.txt
      # Test if this version of df has these OPTIONS.
      df -h --type=cifs --output=source,avail,target >/dev/null 2>&1
      ERROR=$?
      if [ $ERROR -eq 1 ] ; then
         # Older version of df or nothing mounted, so use df with minimal OPTIONS.
         df -h --type=cifs >>temp.txt
         ERROR=$?
         if [ $ERROR -eq 1 ] ; then
            echo >>temp.txt
            echo " >>> Nothing is mounted <<<" >>temp.txt
            echo "No mount-points are mounted." >>temp.txt
         else
            echo >>temp.txt
            grep "//" /etc/mtab | awk -F "," '{ print $1,$5 }' | awk '{ print $5,"mounted",$1}' >>temp.txt
         fi 
      else
         df -h --type=cifs --output=source,avail,target >>temp.txt
         echo >>temp.txt
         grep "//" /etc/mtab | awk -F "," '{ print $1,$5 }' | awk '{ print $5,"mounted",$1}' >>temp.txt
      fi 
      #
      if [ $ERROR -eq 1 ] ; then
         $1 --title "Nothing is mounted" --textbox temp.txt 11 40
      else
         # Get the screen resolution or X-window size.
         # Get rows (height).
         Y=$(stty size | awk '{ print $1 }')
         # Get columns (width).
         X=$(stty size | awk '{ print $2 }')
         #
         $1 --title "Mount-points (use arrow keys to scroll up/down/side-ways)" --textbox temp.txt $Y $X 
      fi
      #
      if [ -r temp.txt ] ; then
         rm temp.txt
      fi
      unset X Y ERROR  # Throw out these variables.
} # End of function f_show_mount_points_gui.
#
# +----------------------------------------+
# |     Function f_display_temp_file_gui   |
# +----------------------------------------+
#
#  Inputs: $1 - "text", "dialog" or "whiptail" The CLI GUI application in use.
#    Uses: temp.txt.
# Outputs: None. 
#
f_display_temp_file_gui () {
      if [ -s temp.txt ] ; then  # File temp.txt contains error message, so display it.
         $1 --textbox temp.txt 20 70
      fi
      #
      if [ -r temp.txt ] ; then
         rm temp.txt
      fi
} # End of function f_display_temp_file_gui.
#
# +----------------------------------------+
# |   Function f_mount_or_dismount_all_gui |
# +----------------------------------------+
#
#  Inputs: $1=GUI - "dialog" or "whiptail" The CLI GUI application in use.
#          $2=Server name.
#          #3 "mount" or "dismount".
#    Uses: ERROR, EXITOUT, NUM, SP, MP.
# Outputs: None.
#
f_mount_or_dismount_all_gui () {
      #
      # Example:
      # Server name is "Server01"
      # Shared directory to be mounted is "//server01/public/contacts"
      # Local PC mount-point is "/mnt/server01/contacts"
      #
      # The arrays are <Server name>_SP=<Server_name>/<Shared directory>
      #                Server01_SP[2]="//mnt/server01/
      #                <Local PC name>_MP=<Local_PC_name>/<Mount-point directory>
      #
      # SERVER[1]="Server01"
      # SERVER_SP[1]="//server01/public/contacts"
      # LOCAL_MP[1]="/mnt/server01/contacts"
      #
      # f_server_arrays
      #
      EXITOUT=0
      NUM=1
      if [ $3 = "mount" ] ; then
         f_username_gui $1 "$USERNAME"
         if [ $ERROR -ne 0 ] ; then  # <Cancel> button was pressed.
            EXITOUT=1
         fi
      fi
      #
      while [ $EXITOUT -eq 0 ]
      do
            # eval allows indirection of array name.
            # echo "\" tells echo to disreguard the first "$" to prevent parameter expansion before passing it to echo which creates the read array command.
            SP=$(eval echo "\$\{$2_SP[$NUM]\}")   # Create command "${<server_name>_SP[$NUM]}" to read string of Shared directory      from array <Server name>_SP[n].
            MP=$(eval echo "\$\{$2_MP[$NUM]\}")   # Create command "${<server_name>_MP[$NUM]}" to read string of Mount-point directory from array <Server name>_MP[n].
                                                  #
            SP=$(eval echo $SP)                   # Read Shared directory from array <Server name>_SP[1].
            if [ -n "$SP" ] ; then                # Does array element exist? (specifying Shared Directory).
               MP=$(eval echo $MP)                # Read Mount-point directory from array <Server name>_MP[1].
               if [ -n "$MP" ] ; then             # Does array element exist? (specifying Mount-Point Directory).
                  if [ $3 = "mount" ] ; then
                     f_mount_gui $1 $SP $MP $SMBUSER $PASSWORD   # Now actually mount the shared directory at the mount-point on the local PC.
                  else
                     f_dismount_gui $1 $MP        # Dismount the mount-point directory.
                  fi
               else
                  EXITOUT=1  # Array element MP does not exist so no more mount-points specified.
               fi
            else
               EXITOUT=1  # Array element SP does not exist so no more shared directories specified.
            fi
            NUM=$(($NUM+1))  #Increment NUM by 1.
      done
      unset EXITOUT NUM SP MP
} # End of function f_mount_or_dismount_all_gui.
#
# +----------------------------------------+
# |           Function f_mount_gui         |
# +----------------------------------------+
#
#  Inputs: $1=GUI - "dialog" or "whiptail" The CLI GUI application in use.
#          $2=Share-point.
#          $3=Mount-point.
#          $4=SMBUSER.
#          $5=PASSWORD.
#    Uses: QUIT, ERROR. temp.txt.
# Outputs: None.
#
f_mount_gui () {
      # mountpoint command 0=directory is a mountpoint (already mounted).
      #                    1=directory is not a mountpoint (not mounted).
      #
      # Test if mounted already, if so, don't mount again or will get error.
      # echo "Share-point="$2  # Diagnostic line.
      # echo "Mount-point="$3  # Diagnostic line.
      #
      QUIT=0
      until [ $QUIT -eq 1 ]  # Start loop.
      do
            # Is the shared directory mounted yet?
            mountpoint $3 >/dev/null 2>temp.txt # Write any error messages to file temp.txt.
            ERROR=$?
            if [ $ERROR -eq 0 ] ; then  # Directory is already mounted. 
               QUIT=1  # Quit loop.
               f_display_temp_file_gui $1
            else  # Directory is not mounted yet.
               if [ -z "$4" ] && [ $QUIT -eq 0 ] ; then
                  f_username_gui $1 "$USERNAME"  # Set the default username to the username that is running this script.
                  if [ $ERROR -ne 0 ] ; then  # <Cancel> button was pressed.
                     EXITOUT=1
                  fi
               fi
               if [ -z "$5" ] && [ $QUIT -eq 0 ] ; then
                  f_password_gui $1 $2
                  if [ $ERROR -eq 1 ] ; then  # <Cancel> button was pressed.
                     QUIT=1  # Quit loop.
                  fi
               fi
               #
               if [ $QUIT -eq 0 ] ; then
                  f_mount_gui2 $1 $2 $3 $SMBUSER $PASSWORD
                  f_test_mount_gui $1 $2 $3  # Output: QUIT=1/0.
               fi
            fi
      if [ -r temp.txt ] ; then
         rm temp.txt
      fi
      done  # End loop.
      unset ERROR QUIT  # Throw out this variable.
} # End of function f_mount_gui.
#
# +----------------------------------------+
# |           Function f_mount_gui2        |
# +----------------------------------------+
#
#  Inputs: $1=GUI - "dialog" or "whiptail" The CLI GUI application in use.
#          $2=Share-point.
#          $3=Mount-point.
#          $4=$SMBUSER (smb username).
#          $5=$PASSWORD (smb password).
#    Uses: None.
# Outputs: ERROR.
#
f_mount_gui2 () {
      sudo mount -o username=$4 -o password=$5 -t cifs $2 $3 2>temp.txt # Write any error messages to file temp.txt.
      ERROR=$?
      # echo "mount -o username=$4 -o password=$5 -t cifs $2 $3"  # Diagnostic line.
      if [ "$ERROR" -ne 0 ] ; then
         unset PASSWORD  # Delete possibly bad password causing mount error.
         echo >>temp.txt
         f_display_temp_file_gui $1
         # Check if host is a Raspberry Pi.
         # XX=$(lsb_release -a | grep -c Raspbian)
         # Raspberry Pi Model 1 cannot use -o password option.
         # Omit the mount -o password flag.
         # if [ $XX ] ; then
         #    sudo mount -o username=$2 -t cifs $2 $3 2>>temp.txt # Write any error messages to file temp.txt.
         #    ERROR=$?
         #   if [ $ERROR -eq 1 ] ; then
         #      f_display_temp_file_gui $1
         #   fi
         # fi
      fi
} # End of function f_mount_gui2.
#
# +----------------------------------------+
# |       Function f_test_mount_gui        |
# +----------------------------------------+
#
#  Inputs: $1=GUI - "dialog" or "whiptail" The CLI GUI application in use.
#          $2=Share-point.
#          $3=Mount-point.
#    Uses: ERROR.
# Outputs: QUIT, temp.txt.
#
f_test_mount_gui () {
      mountpoint $3 >/dev/null 2>temp.txt # Write any error messages to file temp.txt. Get status of mountpoint, mounted?.
      if [ $ERROR -eq 0 ] ; then  # Directory is already mounted. 
         QUIT=1  # Quit loop.
         # echo "Directory $3 is already mounted."  # Diagnostic line.
      else
         # Mount failed, Do you want to try again?
         if [ $1 = "dialog" ] ; then
            $1 --title "Failed to mount" --no-label "No, quit" --yesno "Failed to mount\nShare-point: $2\nonto\nMount-point: $3\n\nTry another password to mount $2?" 10 70
            ERROR=$?
         else
            $1 --title "Failed to mount" --no-button "No, quit" --yesno "Failed to mount\nShare-point: $2\nonto\nMount-point: $3\n\nTry another password to mount $2?" 15 70
            ERROR=$?
         fi
         if [ $ERROR -eq 0 ] ; then  # Outputs user response to $ERROR.
            # ERROR status=0. Yes, try another password to mount Share-point.
            QUIT=0 # Try again to mount.
            unset PASSWORD
         else
            # ERROR status=1. No, do not try another password just return to previous menu. Exit loop.
            QUIT=1 # Quit loop, return to previous menu.
         fi
      fi
} # End of function f_test_mount_gui.
#
# +----------------------------------------+
# |         Function f_dismount_gui        |
# +----------------------------------------+
#
#  Inputs: $1=GUI - "dialog" or "whiptail" The CLI GUI application in use.
#          $2=Mount-point.
#    Uses: ERROR.
# Outputs: None.
#
f_dismount_gui () {
      #
      # mountpoint command 0=directory is a mountpoint (already mounted).
      #                    1=directory is not a mountpoint (not mounted).
      # Test if unmounted already, 
      # if so then don't unmount again or will get mount error.
      #
      #
      mountpoint $2 >/dev/null
      ERROR=$?
      if [ $ERROR -eq 0 ] ; then
         sudo umount $2
      fi
      # Was umount command successful?
      if [ -s temp.txt ] ; then  # File temp.txt contains error message, so display it.
         $1 --textbox temp.txt 20 80
      fi
      #
      if [ -r temp.txt ] ; then
         rm temp.txt
      fi
      # echo "Dismounted $2"  # Diagnostic line.
      unset ERROR
} # End of function f_dismount_gui.
#
# +----------------------------------------+
# |        Function f_update_menu_gui      |
# +----------------------------------------+
#
#  Inputs: $1=GUI - "dialog" or "whiptail" The CLI GUI application in use.
#          $2=GENERATED_FILE.
#    Uses: GENERATED_FILE, ARRAY_NAME, ARRAY_LEN, XNUM, SERVER.
# Outputs: None.
#
f_update_menu_gui () {
      echo "#!/bin/bash" >$2
      echo "#" >>$2
      echo "VERSION=\"$VERSION\"" >>$2
      echo "#" >>$2
      echo "#***********************************CAUTION***********************************" >>$2
      echo "# Any edits made to this code will be lost since this code is" >>$2
      echo "# automatically generated and updated by running the script," >>$2
      echo "# \"mountup_gui.sh\" which contains data for the server menu." >>$2
      echo "#***********************************CAUTION***********************************" >>$2
      echo "#" >>$2
      echo "# +----------------------------------------+" >>$2
      echo "# |        Function f_server_menu_gui      |" >>$2
      echo "# +----------------------------------------+" >>$2
      echo "#" >>$2
      echo "#  Inputs: \$1=GUI." >>$2
      echo "#    Uses: VERSION, THIS_FILE, CHOICE_SERVER, MENU_TITLE." >>$2
      echo "# Outputs: None." >>$2
      echo "#" >>$2
      echo "f_server_menu_gui () {" >>$2
      echo "      # Invoke the file mountup_lib_gui.lib functions to display menu." >>$2
      echo "      . mountup_lib_gui.lib    # invoke the necessary files". >>$2
      echo "      #" >>$2
      echo "      f_server_arrays  # Create arrays from script mountupgui.sh." >>$2
      echo "      #" >>$2
      echo "      CHOICE_SERVER=\"\"  # Initialize variable." >>$2
      echo "      until [ \"\$CHOICE_SERVER\" = \"0\" ]" >>$2
      echo "            do    # Start of Main Menu until loop." >>$2
      echo "               MENU_TITLE=\"Server Menu\"" >>$2
      echo "               CHOICE_SERVER=\$(\$GUI --clear --title \"\$MENU_TITLE\" --menu \"\n\nUse (up/down arrow keys) or (letters):\" 20 80 11 \\" >>$2
      echo "                     \"Quit\" \"Quit to command line prompt.\" \\" >>$2
      echo "                     \"Show\" \"Show mounted directories.\" \\" >>$2
      ARRAY_NAME="SERVER"
      ARRAY_LEN=$(eval "echo \$\{#$ARRAY_NAME[@]\}")
      ARRAY_LEN=$(eval echo $ARRAY_LEN)
            for (( XNUM=1; XNUM<=${ARRAY_LEN}; XNUM++ ));
                do
                   SERVER=$(eval "echo \$\{$ARRAY_NAME[$XNUM]\}")
                   SERVER=$(eval echo $SERVER)
                   if [ -n $SERVER ] ; then
                       echo "                     \"$SERVER\" \"$SERVER fileserver.\" \\" >>$2
                   fi
                done
      echo "                     \"About\" \"Version information of this script.\" \\" >>$2
      echo "                     \"Code History\" \"Display code change history of this script.\" \\" >>$2
      echo "               2>&1 >/dev/tty)" >>$2
      echo "               case \$CHOICE_SERVER in" >>$2
      echo "                    \"Quit\") break ;;" >>$2
      echo "                    \"Show\") f_show_mount_points_gui \$GUI ;;" >>$2
      echo "                    \"About\") f_about_gui \$GUI ;;" >>$2
      echo "                    \"Code History\") f_code_history_gui \$GUI ;;" >>$2
      ARRAY_NAME="SERVER"
      ARRAY_LEN=$(eval "echo \$\{#$ARRAY_NAME[@]\}")
      ARRAY_LEN=$(eval echo $ARRAY_LEN)
            for (( XNUM=1; XNUM<${ARRAY_LEN}; XNUM++ ));
                do
                   SERVER=$(eval "echo \$\{$ARRAY_NAME[$XNUM]\}")
                   SERVER=$(eval echo $SERVER)
                   if [ -n $SERVER ] ; then
                      echo "                    \"${SERVER[$XNUM]}\") f_action_menu_gui \$GUI $SERVER" >>$2
                      echo "                    ;;" >>$2
                   fi
                done
      echo "               esac" >>$2
      echo "       done" >>$2
      echo "       unset VERSION THIS_FILE CHOICE_SERVER MENU_TITLE  # Throw out this variable." >>$2
      echo "       #" >>$2
      echo "       } # End of function f_server_menu_gui." >>$2
      unset ARRAY_NAME ARRAY_LEN XNUM SERVER
} # End of function f_update_menu_gui.
#
# +----------------------------------------+
# |        Function f_action_menu_gui      |
# +----------------------------------------+
#
#  Inputs: $1=GUI - "dialog" or "whiptail" The CLI GUI application in use.
#          $2=Server name.
#    Uses: CHOICE_ACT, PASSWORD, MENU_TITLE.
# Outputs: None.
#
f_action_menu_gui () {
      # Invoke the file mountup_lib_gui.lib functions to display menu.
      . mountup_lib_gui.lib    # invoke the necessary files.
      f_server_arrays
      CHOICE_ACT=-1
      until [ "$CHOICE_ACT" = "0" ]
      do    # Start of Mount/Dismount File Server Menu until loop.
            unset PASSWORD
            MENU_TITLE="Mount/Dismount $2 File Server Menu"
            CHOICE_ACT=$($1 --clear --title "$MENU_TITLE" --menu "\n\n For $2 server - Use (up/down arrow keys) or (letters):" 20 80 11 \
                   "Quit" "Quit to command line prompt." \
                   "Show" "Show mounted directories." \
                   "Mount all" "Mount all shared directories." \
                   "Dismount all" "Dismount all shared directories." \
                   "Pick" "Pick shared directories to mount or dismount."\
            2>&1 >/dev/tty)
            #
            case $CHOICE_ACT in
                 "Quit") break ;;
                 "Show") f_show_mount_points_gui $1 ;;
                 "Mount all") f_test_connection $1 $2
                         if [ $ERROR -eq 0 ] ; then
                            f_mount_or_dismount_all_gui $1 $2 "mount"
                         fi
                         f_show_mount_points_gui $1
                         ;;
                 "Dismount all")
                         f_test_connection $1 $2
                         if [ $ERROR -eq 0 ] ; then
                            f_mount_or_dismount_all_gui $1 $2 "dismount"
                         fi
                         f_show_mount_points_gui $1
                         ;;
                 "Pick")
                         f_test_connection $1 $2
                         if [ $ERROR -eq 0 ] ; then
                            f_pick_menu_gui $1 $2 mountup_sharepoints_menu_gui.lib
                         fi
                         f_show_mount_points_gui $1
                         ;;
            esac
      done  # End of Mount/Dismount File Server Menu until loop.
      #
      if [ -r mountup_sharepoints_menu_gui.lib ] ; then
         rm mountup_sharepoints_menu_gui.lib
      fi
      unset CHOICE_ACT PASSWORD MENU_TITLE # Throw out this variable.
} # End of function f_action_menu_gui.
#
# +----------------------------------------+
# |        Function f_pick_menu_gui        |
# +----------------------------------------+
#
#  Inputs: $1=GUI - "dialog" or "whiptail" The CLI GUI application in use.
#          $2=SERVER NAME.
#          $3=GENERATED_FILE.
#    Uses: GENERATED_FILE, ARRAY_NAME, ARRAY_LEN, XNUM, SERVER, MP, SP, ERROR, MOUNT_POINT_DESC.
# Outputs: STATUS[XNUM], $2_DESC[XNUM].
#
f_pick_menu_gui () {
      echo "#!/bin/bash" >$3
      echo "#" >>$3
      echo "VERSION=\"$VERSION\"" >>$3
      echo "#" >>$3
      echo "#***********************************CAUTION***********************************" >>$3
      echo "# Any edits made to this code will be lost since this code is" >>$3
      echo "# automatically generated and updated by running the function," >>$3
      echo "# \"f_action_update_gui\" within the library script \"mountup_lib_gui.lib\"" >>$3
      echo "# which is called by script \"mountup_gui.sh\"." >>$3
      echo "#***********************************CAUTION***********************************" >>$3
      echo "#" >>$3
      echo "# +----------------------------------------+" >>$3
      echo "# |        Function f_checklist_mp_gui     |" >>$3
      echo "# +----------------------------------------+" >>$3
      echo "#" >>$3
      echo "#  Inputs: \$1=Server name." >>$3
      echo "#    Uses: None." >>$3
      echo "# Outputs: CHOICE_ACT." >>$3
      echo "#" >>$3
      echo "f_checklist_mp_gui () {" >>$3
      f_server_arrays
      ARRAY_NAME="$2_DESC"
      ARRAY_LEN=$(eval "echo \$\{#\$ARRAY_NAME[@]\}")
      ARRAY_LEN=$(eval echo $ARRAY_LEN)
      #
      for (( XNUM=1; XNUM<=${ARRAY_LEN}; XNUM++ ));
          do
             MP=$(eval echo "\$\{$2_MP[$XNUM]\}")   # Create command "${<server_name>_MP[$NUM]}" from array <Server name>_MP[n].
             MP=$(eval echo $MP)
             #
             mountpoint $MP >/dev/null  # Get status of mountpoint, mounted?.
             ERROR=$?
             if [ $ERROR -eq 1 ] ; then  # Directory is not mounted.
                STATUS[$XNUM]="off"
                # echo "$MP is not mounted."  # Diagnostic line.
             else                        # Directory is mounted.
                STATUS[$XNUM]="on"
                # echo "$MP is mounted."  # Diagnostic line.
             fi              
             #
          done
          #
      echo "CHOICE_ACT=\$($1 --checklist \"Choose $2 shared directory:\" 20 80 11 \\" >>$3
      #
      for (( XNUM=1; XNUM<=${ARRAY_LEN}; XNUM++ ));
          do
             MOUNT_POINT_DESC=$(eval "echo \$\{$ARRAY_NAME[$XNUM]\}")
             MOUNT_POINT_DESC=$(eval echo $MOUNT_POINT_DESC)
             MOUNT_POINT_DESC=$(echo $MOUNT_POINT_DESC | tr '_' ' ')  #Substitute <underscores> to <spaces>.
             echo "$XNUM '$MOUNT_POINT_DESC' ${STATUS[$XNUM]} \\" >>$3
          done
      echo "2>&1 >/dev/tty)" >>$3
      echo "} # End of function f_checklist_mp_gui." >>$3
      #
      # Invoke the file $3 which contains the function, f_checklist_mp.
      . $3
      f_checklist_mp_gui $2
      ERROR=$?
      # echo "Exit code ERROR=$ERROR"  # Diagnostic line.
      # echo "CHOICE_ACT=$CHOICE_ACT"  # Diagnostic line.
      # f_press_enter_key_to_continue  # Diagnostic line.
      #
      if [ $ERROR = 0 ] ; then  # If <Cancel> button was not pressed.
         for (( XNUM=1; XNUM<=${ARRAY_LEN}; XNUM++ ));
             do
                SP=$(eval echo "\$\{$2_SP[$XNUM]\}")   # Create command "${<server_name>_SP[$NUM]}" from array <Server name>_SP[n].
                SP=$(eval echo $SP)
                #
                MP=$(eval echo "\$\{$2_MP[$XNUM]\}")   # Create command "${<server_name>_MP[$NUM]}" from array <Server name>_MP[n].
                MP=$(eval echo $MP)
                #
                # echo "XNUM=$XNUM"  # Diagnostic line.
                # echo "SP=$SP"      # Diagnostic line.
                # echo "MP=$MP"      # Diagnostic line.
                # echo "CHOICE_ACT=$CHOICE_ACT" # Diagnostic line.
                # echo "f_pick_match $1 $XNUM $SP $MP"  # Diagnostic line.
                f_pick_match $1 $XNUM $SP $MP  # CHOICE_ACT cannot be passed as a parameter because string contains <spaces>.
                # f_press_enter_key_to_continue  # Diagnostic line.
                # echo  # Diagnostic line.
             done
      fi
}  # End of function f_pick_menu_gui
#
# +----------------------------------------+
# |         Function f_pick_match          |
# +----------------------------------------+
#
#  Inputs: $1=GUI - "dialog" or "whiptail" The CLI GUI application in use.
#          $2=XNUM
#          $3=SP Share-point.
#          $4=MP Mount-point.
#          CHOICE_ACT
#    Uses: MNT.
# Outputs: None.
#
f_pick_match () {
      if [[ "$CHOICE_ACT" =~ "$2" ]] ; then  # Does CHOICE_ACT contain XNUM?
         for MNT in $CHOICE_ACT
             do
                if [[ $MNT =~ $2 ]] ; then
                   # echo "Mount $3 on $4"  # Diagnostic line.
                   f_mount_gui $1 $3 $4 # Yes, so mount it.
                fi
            done
      else  # No CHOICE_ACT does not contain XNUM, so unmount it.
         # echo "Unmount $4 from $3"  # Diagnostic line.
         f_dismount_gui $1 $4
      fi
      unset MNT
}  # End of function f_pick_match
